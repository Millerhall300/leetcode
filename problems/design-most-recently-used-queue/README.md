<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../closest-subsequence-sum "Closest Subsequence Sum")
　　　　　　　　　　　　　　　　
[Next >](../recyclable-and-low-fat-products "Recyclable and Low Fat Products")

## [1756. Design Most Recently Used Queue (Medium)](https://leetcode.com/problems/design-most-recently-used-queue "设计最近使用（MRU）队列")



### Related Topics
  [[Design](../../tag/design/README.md)]
  [[Array](../../tag/array/README.md)]

### Hints
<details>
<summary>Hint 1</summary>
You can store the data in an array and apply each fetch by moving the ith element to the end of the array (i.e, O(n) per operation).
</details>

<details>
<summary>Hint 2</summary>
A better way is to use the square root decomposition technique.
</details>

<details>
<summary>Hint 3</summary>
You can build chunks of size sqrt(n). For each fetch operation, You can search for the chunk which has the ith element and update it (i.e., O(sqrt(n)) per operation), and move this element to an empty chunk at the end.
</details>
