<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../maximum-binary-string-after-change "Maximum Binary String After Change")
　　　　　　　　　　　　　　　　
[Next >](../determine-if-string-halves-are-alike "Determine if String Halves Are Alike")

## [1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)](https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones "得到连续 K 个 1 的最少相邻交换次数")

<p>You are given an integer array, <code>nums</code>, and an integer <code>k</code>. <code>nums</code> comprises of only <code>0</code>&#39;s and <code>1</code>&#39;s. In one move, you can choose two <strong>adjacent</strong> indices and swap their values.</p>

<p>Return <em>the <strong>minimum</strong> number of moves required so that </em><code>nums</code><em> has </em><code>k</code><em> <strong>consecutive</strong> </em><code>1</code><em>&#39;s</em>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,0,1,0,1], k = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> In 1 move, nums could be [1,0,0,0,<u>1</u>,<u>1</u>] and have 2 consecutive 1&#39;s.
</pre>

<p><strong>Example 2:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,0,0,0,0,0,1,1], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,<u>1</u>,<u>1</u>,<u>1</u>].
</pre>

<p><strong>Example 3:</strong></p>

<pre>
<strong>Input:</strong> nums = [1,1,0,1], k = 2
<strong>Output:</strong> 0
<strong>Explanation:</strong> nums already has 2 consecutive 1&#39;s.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> is <code>0</code> or <code>1</code>.</li>
	<li><code>1 &lt;= k &lt;= sum(nums)</code></li>
</ul>

### Related Topics
  [[Array](../../tag/array/README.md)]
  [[Greedy](../../tag/greedy/README.md)]
  [[Sliding Window](../../tag/sliding-window/README.md)]
  [[Prefix Sum](../../tag/prefix-sum/README.md)]

### Similar Questions
  1. [Minimum Swaps to Group All 1's Together](../minimum-swaps-to-group-all-1s-together) (Medium)
  1. [Minimum Number of Operations to Make Array Continuous](../minimum-number-of-operations-to-make-array-continuous) (Hard)

### Hints
<details>
<summary>Hint 1</summary>
Choose k 1s and determine how many steps are required to move them into 1 group.
</details>

<details>
<summary>Hint 2</summary>
Maintain a sliding window of k 1s, and maintain the steps required to group them.
</details>

<details>
<summary>Hint 3</summary>
When you slide the window across, should you move the group to the right? Once you move the group to the right, it will never need to slide to the left again.
</details>
