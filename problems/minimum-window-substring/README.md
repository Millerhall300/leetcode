<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../sort-colors "Sort Colors")
　　　　　　　　　　　　　　　　
[Next >](../combinations "Combinations")

## [76. Minimum Window Substring (Hard)](https://leetcode.com/problems/minimum-window-substring "最小覆盖子串")

<p>Given two strings <code>s</code> and <code>t</code>&nbsp;of lengths&nbsp;<code>m</code>&nbsp;and <code>n</code>&nbsp;respectively, return <em>the minimum window in <code>s</code> which will contain all the characters in <code>t</code></em>. If there is no such window in <code>s</code> that covers all characters in <code>t</code>, return <em>the empty string <code>&quot;&quot;</code></em>.</p>

<p><strong>Note</strong> that If there is such a window, it is&nbsp;guaranteed that there will always be only one unique minimum window in <code>s</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<pre><strong>Input:</strong> s = "ADOBECODEBANC", t = "ABC"
<strong>Output:</strong> "BANC"
</pre><p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong> s = "a", t = "a"
<strong>Output:</strong> "a"
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == s.length</code></li>
	<li><code>n == t.length</code></li>
	<li><code>1 &lt;= m, n&nbsp;&lt;= 10<sup>5</sup></code></li>
	<li><code>s</code> and <code>t</code> consist of English letters.</li>
</ul>

<p>&nbsp;</p>
<strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?

### Related Topics
  [[Hash Table](../../tag/hash-table/README.md)]
  [[Two Pointers](../../tag/two-pointers/README.md)]
  [[String](../../tag/string/README.md)]
  [[Sliding Window](../../tag/sliding-window/README.md)]

### Similar Questions
  1. [Substring with Concatenation of All Words](../substring-with-concatenation-of-all-words) (Hard)
  1. [Minimum Size Subarray Sum](../minimum-size-subarray-sum) (Medium)
  1. [Sliding Window Maximum](../sliding-window-maximum) (Hard)
  1. [Permutation in String](../permutation-in-string) (Medium)
  1. [Minimum Window Subsequence](../minimum-window-subsequence) (Hard)

### Hints
<details>
<summary>Hint 1</summary>
Use two pointers to create a window of letters in <b>S</b>, which would have all the characters from <b>T</b>.
</details>

<details>
<summary>Hint 2</summary>
Since you have to find the minimum window in <b>S</b> which has all the characters from <b>T</b>, you need to expand and contract the window using the two pointers and keep checking the window for all the characters. This approach is also called Sliding Window Approach.

<br><br>
<pre>
L ------------------------ R , Suppose this is the window that contains all characters of <b>T</b> 
                          
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp L----------------- R , this is the contracted window. We found a smaller window that still contains all the characters in <b>T</b>

When the window is no longer valid, start expanding again using the right pointer. </pre>
</details>
