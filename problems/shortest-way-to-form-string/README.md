<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../distant-barcodes "Distant Barcodes")
　　　　　　　　　　　　　　　　
[Next >](../confusing-number "Confusing Number")

## [1055. Shortest Way to Form String (Medium)](https://leetcode.com/problems/shortest-way-to-form-string "形成字符串的最短路径")



### Related Topics
  [[Greedy](../../tag/greedy/README.md)]
  [[String](../../tag/string/README.md)]
  [[Dynamic Programming](../../tag/dynamic-programming/README.md)]

### Similar Questions
  1. [Is Subsequence](../is-subsequence) (Easy)

### Hints
<details>
<summary>Hint 1</summary>
Which conditions have to been met in order to be impossible to form the target string?
</details>

<details>
<summary>Hint 2</summary>
If there exists a character in the target string which doesn't exist in the source string then it will be impossible to form the target string.
</details>

<details>
<summary>Hint 3</summary>
Assuming we are in the case which is possible to form the target string, how can we assure the minimum number of used subsequences of source?
</details>

<details>
<summary>Hint 4</summary>
For each used subsequence try to match the leftmost character of the current subsequence with the leftmost character of the target string, if they match then erase both character otherwise erase just the subsequence character whenever the current subsequence gets empty, reset it to a new copy of subsequence and increment the count, do this until the target sequence gets empty. Finally return the count.
</details>
