<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    awesee <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/awesee                                 |-->
<!--|@home      https://github.com/awesee/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../minimum-time-to-remove-all-cars-containing-illegal-goods "Minimum Time to Remove All Cars Containing Illegal Goods")
　　　　　　　　　　　　　　　　
[Next >](../count-operations-to-obtain-zero "Count Operations to Obtain Zero")

## [2168. Unique Substrings With Equal Digit Frequency (Medium)](https://leetcode.com/problems/unique-substrings-with-equal-digit-frequency "")



### Related Topics
  [[Hash Table](../../tag/hash-table/README.md)]
  [[String](../../tag/string/README.md)]
  [[Counting](../../tag/counting/README.md)]
  [[Hash Function](../../tag/hash-function/README.md)]
  [[Rolling Hash](../../tag/rolling-hash/README.md)]

### Hints
<details>
<summary>Hint 1</summary>
With the constraints, could we try every substring?
</details>

<details>
<summary>Hint 2</summary>
Yes, checking every substring has runtime O(n^2), which will pass.
</details>

<details>
<summary>Hint 3</summary>
How can we make sure we only count unique substrings?
</details>

<details>
<summary>Hint 4</summary>
Use a set to store previously counted substrings. Hashing a string s of length m takes O(m) time. Is there a fast way to compute the hash of s if we know the hash of s[0..m - 2]?
</details>

<details>
<summary>Hint 5</summary>
Use a rolling hash.
</details>
